/**
 * –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –¥–ª—è –≤—Å–µ—Ö API endpoints
 * 
 * –≠—Ç–æ—Ç —Ö–µ–ª–ø–µ—Ä –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç:
 * 1. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ 401
 * 2. –ü–æ–≤—Ç–æ—Ä –∑–∞–ø—Ä–æ—Å–∞ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ —Ç–æ–∫–µ–Ω–∞–º–∏
 * 3. –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
 * 4. –ü–æ–¥–¥–µ—Ä–∂–∫—É –∫–∞–∫ –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–π, —Ç–∞–∫ –∏ —Å–µ—Ä–≤–µ—Ä–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
 */

import { NextRequest, NextResponse } from 'next/server';

export interface AuthHandlerOptions {
  /** –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ª–∏ toast —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è (—Ç–æ–ª—å–∫–æ –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ) */
  showToast?: boolean;
  /** –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è—Ç—å –ª–∏ –Ω–∞ –ª–æ–≥–∏–Ω –ø—Ä–∏ –Ω–µ—É–¥–∞—á–µ (—Ç–æ–ª—å–∫–æ –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ) */
  redirectToLogin?: boolean;
  /** Callback URL –¥–ª—è –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
  callbackUrl?: string;
  /** –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ */
  headers?: Record<string, string>;
}

export interface AuthHandlerResult {
  success: boolean;
  response?: Response;
  error?: string;
  shouldRetry?: boolean;
}

/**
 * –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –¥–ª—è –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
 */
export async function handleClientAuth(
  input: RequestInfo | URL,
  init: RequestInit = {},
  options: AuthHandlerOptions = {}
): Promise<Response> {
  const {
    showToast = true,
    redirectToLogin = true,
    callbackUrl,
    headers = {}
  } = options;

  console.log('[UniversalAuth] Making authenticated request to:', input);

  // –î–µ–ª–∞–µ–º –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—ã–π –∑–∞–ø—Ä–æ—Å
  const response = await fetch(input, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...headers,
      ...(init.headers || {})
    },
    cache: 'no-store'
  });

  // –ï—Å–ª–∏ –Ω–µ 401, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–≤–µ—Ç –∫–∞–∫ –µ—Å—Ç—å
  if (response.status !== 401) {
    console.log('[UniversalAuth] Request successful, status:', response.status);
    return response;
  }

  console.log('[UniversalAuth] ‚ö†Ô∏è Received 401, attempting token refresh...');

  // –ü—ã—Ç–∞–µ–º—Å—è –æ–±–Ω–æ–≤–∏—Ç—å —Ç–æ–∫–µ–Ω—ã
  try {
    const origin = typeof window !== 'undefined' ? window.location.origin : process.env.NEXTAUTH_URL || 'http://localhost:3000';
    const refreshResponse = await fetch(`${origin}/api/auth/refresh`, {
      method: 'POST',
      cache: 'no-store',
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (refreshResponse.ok) {
      console.log('[UniversalAuth] ‚úÖ Token refresh successful, retrying request...');
      
      // –ü–æ–≤—Ç–æ—Ä—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –∑–∞–ø—Ä–æ—Å —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ —Ç–æ–∫–µ–Ω–∞–º–∏
      const retryResponse = await fetch(input, {
        ...init,
        headers: {
          'Content-Type': 'application/json',
          ...headers,
          ...(init.headers || {})
        },
        cache: 'no-store'
      });

      if (retryResponse.status !== 401) {
        console.log('[UniversalAuth] ‚úÖ Retry successful, status:', retryResponse.status);
        return retryResponse;
      }

      console.log('[UniversalAuth] ‚ùå Retry still returned 401, tokens are invalid');
    } else {
      console.log('[UniversalAuth] ‚ùå Token refresh failed, status:', refreshResponse.status);
    }
  } catch (error) {
    console.error('[UniversalAuth] ‚ùå Error during token refresh:', error);
  }

  // –ï—Å–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤ –Ω–µ –ø–æ–º–æ–≥–ª–æ
  if (typeof window !== 'undefined') {
    console.log('[UniversalAuth] üîÑ Authentication failed, handling redirect...');

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    if (showToast) {
      try {
        const { toast } = await import('@/hooks/use-toast');
        toast({
          title: "–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è",
          description: "–í–∞—à–∞ —Å–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ä–µ—Å—É—Ä—Å–∞–º.",
          variant: "destructive",
          duration: 5000,
        });
      } catch (err) {
        console.error('[UniversalAuth] Failed to show toast:', err);
      }
    }

    // –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –ª–æ–≥–∏–Ω–∞
    if (redirectToLogin) {
      setTimeout(() => {
        const currentUrl = callbackUrl || window.location.pathname + window.location.search;
        const encodedCallback = encodeURIComponent(currentUrl);
        window.location.href = `/login?callbackUrl=${encodedCallback}&message=${encodeURIComponent('–í–∞—à–∞ —Å–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.')}`;
      }, 500);
    }
  }

  return response;
}

/**
 * –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –¥–ª—è —Å–µ—Ä–≤–µ—Ä–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
 */
export async function handleServerAuth(
  request: NextRequest,
  url: string,
  options: RequestInit = {},
  authOptions: AuthHandlerOptions = {}
): Promise<Response> {
  console.log('[UniversalAuth] Making server-side authenticated request to:', url);

  try {
    // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º ServerAuthManager
    const { ServerAuthManager } = await import('./serverAuth');
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º ServerAuthManager –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    const response = await ServerAuthManager.authenticatedFetch(request, url, options);
    
    console.log('[UniversalAuth] Server request successful, status:', response.status);
    return response;
    
  } catch (error) {
    console.error('[UniversalAuth] Server authentication failed:', error);
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º 401 –æ—Ç–≤–µ—Ç –¥–ª—è —Å–µ—Ä–≤–µ—Ä–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
    return new Response(
      JSON.stringify({
        error: 'Authentication failed',
        message: 'No valid authentication tokens available',
        requiresAuth: true
      }),
      {
        status: 401,
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );
  }
}

/**
 * –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ 401 –æ—à–∏–±–æ–∫ –≤ API endpoints
 */
export function createAuthErrorResponse(
  message: string = 'Authentication required',
  redirectTo: string = '/login'
): NextResponse {
  return NextResponse.json(
    {
      success: false,
      error: 'NOT_AUTHENTICATED',
      message,
      requiresAuth: true,
      redirectTo,
      callbackUrl: '/login'
    },
    { status: 401 }
  );
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—Ç–≤–µ—Ç 401 –æ—à–∏–±–∫–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
 */
export function isAuthError(response: Response): boolean {
  return response.status === 401;
}

/**
 * –ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—à–∏–±–∫–µ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏–∑ –æ—Ç–≤–µ—Ç–∞
 */
export async function parseAuthError(response: Response): Promise<{
  isAuthError: boolean;
  message?: string;
  requiresAuth?: boolean;
  redirectTo?: string;
}> {
  if (!isAuthError(response)) {
    return { isAuthError: false };
  }

  try {
    const data = await response.json();
    return {
      isAuthError: true,
      message: data.message || 'Authentication required',
      requiresAuth: data.requiresAuth || false,
      redirectTo: data.redirectTo || '/login'
    };
  } catch {
    return {
      isAuthError: true,
      message: 'Authentication required'
    };
  }
}

/**
 * –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Ö–µ–ª–ø–µ—Ä –¥–ª—è API endpoints —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π 401
 */
export async function withAuth<T>(
  authFunction: () => Promise<T>,
  fallback?: () => T
): Promise<T> {
  try {
    return await authFunction();
  } catch (error: any) {
    if (error.message?.includes('Authentication failed') || 
        error.message?.includes('No authentication tokens')) {
      console.log('[UniversalAuth] Authentication error caught, using fallback');
      return fallback ? fallback() : null as T;
    }
    throw error;
  }
}
