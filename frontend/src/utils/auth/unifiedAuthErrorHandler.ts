"use client";

import { toast } from "@/hooks/use-toast";

/**
 * üîê –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ 401/4001
 * 
 * –õ–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏:
 * 1. –ü–æ–ª—É—á–∏–ª–∏ 401/4001 ‚Üí –ø—Ä–æ–≤–µ—Ä—è–µ–º refresh —Ç–æ–∫–µ–Ω –≤ Redis
 * 2. –ï—Å–ª–∏ –µ—Å—Ç—å refresh ‚Üí –¥–µ–ª–∞–µ–º refresh (–Ω–æ–≤—ã–µ —Ç–æ–∫–µ–Ω—ã —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ Redis)
 * 3. Retry –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
 * 4. –ï—Å–ª–∏ —Å–Ω–æ–≤–∞ 401 –∏–ª–∏ refresh –≤–µ—Ä–Ω—É–ª 403 ‚Üí —Ä–µ–¥–∏—Ä–µ–∫—Ç –Ω–∞ –ª–æ–≥–∏–Ω —Å toast
 * 
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è:
 * - HTTP requests (fetch, apiClient)
 * - WebSocket connections (code 4001)
 */

interface AuthErrorHandlerOptions {
  /** Callback –¥–ª—è retry –∑–∞–ø—Ä–æ—Å–∞ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ refresh */
  retryRequest?: () => Promise<Response>;
  /** –î–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è - —Ç–∏–ø –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –æ—à–∏–±–∫–∏ */
  source?: string;
  /** –¢–µ–∫—É—â–∏–π –ø—É—Ç—å –¥–ª—è redirect callback */
  currentPath?: string;
  /** –ü–æ–∫–∞–∑–∞—Ç—å –ª–∏ toast –ø—Ä–∏ redirect */
  showToast?: boolean;
}

interface AuthErrorHandlerResult {
  /** –£—Å–ø–µ—à–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã —Ç–æ–∫–µ–Ω—ã */
  refreshSucceeded: boolean;
  /** –†–µ–∑—É–ª—å—Ç–∞—Ç retry –∑–∞–ø—Ä–æ—Å–∞ (–µ—Å–ª–∏ –±—ã–ª) */
  retryResponse?: Response;
  /** –ù—É–∂–µ–Ω –ª–∏ —Ä–µ–¥–∏—Ä–µ–∫—Ç –Ω–∞ –ª–æ–≥–∏–Ω */
  shouldRedirect: boolean;
}

class UnifiedAuthErrorHandler {
  private isRefreshing = false;
  private refreshPromise: Promise<boolean> | null = null;

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç —Ç–æ–∫–µ–Ω—ã –∏–∑ Redis
   */
  private async getTokensFromRedis(): Promise<{ access?: string; refresh?: string } | null> {
    try {
      const response = await fetch('/api/redis?key=backend_auth');
      if (!response.ok) return null;

      const data = await response.json();
      if (!data?.value) return null;

      const authData = typeof data.value === 'string' ? JSON.parse(data.value) : data.value;
      return {
        access: authData.access,
        refresh: authData.refresh
      };
    } catch (error) {
      console.error('[UnifiedAuthErrorHandler] Error getting tokens from Redis:', error);
      return null;
    }
  }

  /**
   * –û–±–Ω–æ–≤–ª—è–µ—Ç —Ç–æ–∫–µ–Ω—ã —á–µ—Ä–µ–∑ API
   * –ù–æ–≤—ã–µ —Ç–æ–∫–µ–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ Redis –≤–Ω—É—Ç—Ä–∏ /api/auth/refresh
   */
  private async refreshTokensInternal(): Promise<boolean> {
    try {
      console.log('[UnifiedAuthErrorHandler] üîÑ Refreshing tokens...');
      
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        cache: 'no-store'
      });

      if (response.status === 403) {
        console.error('[UnifiedAuthErrorHandler] ‚ùå Refresh failed with 403 - refresh token invalid');
        return false;
      }

      if (!response.ok) {
        console.error('[UnifiedAuthErrorHandler] ‚ùå Token refresh failed:', response.status);
        return false;
      }

      const data = await response.json();
      console.log('[UnifiedAuthErrorHandler] ‚úÖ Token refresh successful');
      
      // –¢–æ–∫–µ–Ω—ã —É–∂–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ Redis —á–µ—Ä–µ–∑ /api/auth/refresh
      return !!data.access;
    } catch (error) {
      console.error('[UnifiedAuthErrorHandler] ‚ùå Error refreshing tokens:', error);
      return false;
    }
  }

  /**
   * –û–±–Ω–æ–≤–ª—è–µ—Ç —Ç–æ–∫–µ–Ω—ã —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤
   */
  async refreshTokens(): Promise<boolean> {
    // –ï—Å–ª–∏ —É–∂–µ –∏–¥–µ—Ç refresh - –∂–¥–µ–º –µ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    if (this.isRefreshing && this.refreshPromise) {
      console.log('[UnifiedAuthErrorHandler] ‚è≥ Refresh already in progress, waiting...');
      return await this.refreshPromise;
    }

    // –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π refresh
    this.isRefreshing = true;
    this.refreshPromise = this.refreshTokensInternal();

    try {
      const result = await this.refreshPromise;
      return result;
    } finally {
      this.isRefreshing = false;
      this.refreshPromise = null;
    }
  }

  /**
   * –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç toast –∏ –¥–µ–ª–∞–µ—Ç —Ä–µ–¥–∏—Ä–µ–∫—Ç –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –ª–æ–≥–∏–Ω–∞
   */
  private handleRedirectToLogin(options: AuthErrorHandlerOptions) {
    const { currentPath, showToast = true } = options;

    if (showToast) {
      toast({
        title: "‚ùå –¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è",
        description: "–í–∞—à–∞ —Å–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.",
        variant: "destructive",
        duration: 5000,
      });
    }

    if (typeof window !== 'undefined') {
      const path = currentPath || window.location.pathname + window.location.search;
      const callback = encodeURIComponent(path);
      
      setTimeout(() => {
        window.location.href = `/login?callbackUrl=${callback}&message=${encodeURIComponent('–í–∞—à–∞ —Å–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.')}`;
      }, 500);
    }
  }

  /**
   * –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–∫–∏ 401/4001
   * 
   * –ê–ª–≥–æ—Ä–∏—Ç–º:
   * 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ refresh —Ç–æ–∫–µ–Ω–∞ –≤ Redis
   * 2. –ï—Å–ª–∏ –µ—Å—Ç—å ‚Üí –¥–µ–ª–∞–µ–º refresh
   * 3. –ï—Å–ª–∏ refresh —É—Å–ø–µ—à–µ–Ω ‚Üí retry –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ (–µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω callback)
   * 4. –ï—Å–ª–∏ —Å–Ω–æ–≤–∞ 401 –∏–ª–∏ refresh failed (403) ‚Üí —Ä–µ–¥–∏—Ä–µ–∫—Ç –Ω–∞ –ª–æ–≥–∏–Ω
   */
  async handleAuthError(options: AuthErrorHandlerOptions = {}): Promise<AuthErrorHandlerResult> {
    const { retryRequest, source = 'unknown' } = options;

    console.log(`[UnifiedAuthErrorHandler] üîê Handling 401 error from: ${source}`);

    // –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ refresh —Ç–æ–∫–µ–Ω–∞ –≤ Redis
    const tokens = await this.getTokensFromRedis();
    
    if (!tokens?.refresh) {
      console.error('[UnifiedAuthErrorHandler] ‚ùå No refresh token in Redis - redirecting to login');
      this.handleRedirectToLogin(options);
      return {
        refreshSucceeded: false,
        shouldRedirect: true
      };
    }

    console.log('[UnifiedAuthErrorHandler] ‚úÖ Refresh token found in Redis');

    // –®–∞–≥ 2: –î–µ–ª–∞–µ–º refresh —Ç–æ–∫–µ–Ω–æ–≤
    const refreshSuccess = await this.refreshTokens();

    if (!refreshSuccess) {
      console.error('[UnifiedAuthErrorHandler] ‚ùå Token refresh failed - redirecting to login');
      this.handleRedirectToLogin(options);
      return {
        refreshSucceeded: false,
        shouldRedirect: true
      };
    }

    console.log('[UnifiedAuthErrorHandler] ‚úÖ Token refresh successful');

    // –®–∞–≥ 3: Retry –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ (–µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω callback)
    if (retryRequest) {
      console.log('[UnifiedAuthErrorHandler] üîÑ Retrying original request...');
      
      try {
        const retryResponse = await retryRequest();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç retry
        if (retryResponse.status === 401) {
          console.error('[UnifiedAuthErrorHandler] ‚ùå Retry still returned 401 - tokens invalid');
          this.handleRedirectToLogin(options);
          return {
            refreshSucceeded: true,
            retryResponse,
            shouldRedirect: true
          };
        }

        console.log('[UnifiedAuthErrorHandler] ‚úÖ Retry successful:', retryResponse.status);
        return {
          refreshSucceeded: true,
          retryResponse,
          shouldRedirect: false
        };
      } catch (error) {
        console.error('[UnifiedAuthErrorHandler] ‚ùå Error during retry:', error);
        this.handleRedirectToLogin(options);
        return {
          refreshSucceeded: true,
          shouldRedirect: true
        };
      }
    }

    // –ï—Å–ª–∏ retry callback –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω - –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —É—Å–ø–µ—Ö refresh
    return {
      refreshSucceeded: true,
      shouldRedirect: false
    };
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ WebSocket –æ—à–∏–±–∫–∏ 4001
   * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç true –µ—Å–ª–∏ –º–æ–∂–Ω–æ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è, false –µ—Å–ª–∏ –Ω—É–∂–µ–Ω —Ä–µ–¥–∏—Ä–µ–∫—Ç
   */
  async handleWebSocketAuthError(options: Omit<AuthErrorHandlerOptions, 'retryRequest'> = {}): Promise<boolean> {
    const result = await this.handleAuthError({
      ...options,
      source: options.source || 'WebSocket'
    });

    // –î–ª—è WebSocket –Ω–µ –¥–µ–ª–∞–µ–º retry –∑–∞–ø—Ä–æ—Å–∞, —Ç–æ–ª—å–∫–æ refresh —Ç–æ–∫–µ–Ω–æ–≤
    // Caller —Å–∞–º –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—Å—è —Å –Ω–æ–≤—ã–º —Ç–æ–∫–µ–Ω–æ–º
    return result.refreshSucceeded && !result.shouldRedirect;
  }
}

// Singleton instance
export const unifiedAuthErrorHandler = new UnifiedAuthErrorHandler();

/**
 * Helper –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ fetch
 */
export async function handleFetchAuthError(
  originalRequest: () => Promise<Response>,
  options: Omit<AuthErrorHandlerOptions, 'retryRequest'> = {}
): Promise<Response> {
  const result = await unifiedAuthErrorHandler.handleAuthError({
    ...options,
    retryRequest: originalRequest,
    source: options.source || 'fetch'
  });

  if (result.retryResponse) {
    return result.retryResponse;
  }

  // –ï—Å–ª–∏ –¥–æ—à–ª–∏ —Å—é–¥–∞ –±–µ–∑ retryResponse - –∑–Ω–∞—á–∏—Ç –ø—Ä–æ–∏–∑–æ—à–µ–ª —Ä–µ–¥–∏—Ä–µ–∫—Ç
  // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–µ–π–∫–æ–≤—ã–π 401 response
  return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });
}

