#!/usr/bin/env python3
"""
Tool for encrypting API keys for secure storage in environment variables.
"""
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List

# Add Django project to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

# Setup Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
import django
django.setup()

from core.security import encryption_service, key_manager


class KeyEncryptionTool:
    """Tool for encrypting API keys."""
    
    def __init__(self):
        self.known_keys = {
            'GOOGLE_MAPS_API_KEY': 'Google Maps API Key',
            'GOOGLE_API_KEY': 'Google API Key',
            'GOOGLE_SEARCH_ENGINE_ID': 'Google Search Engine ID',
            'GOOGLE_CLIENT_ID': 'Google OAuth Client ID',
            'GOOGLE_CLIENT_SECRET': 'Google OAuth Client Secret',
            'BING_API_KEY': 'Bing Search API Key',
            'RIZA_API_KEY': 'Riza.io API Key',
            'OPENAI_API_KEY': 'OpenAI API Key',
            'TAVILY_API_KEY': 'Tavily Search API Key',
            # MinIO —É–¥–∞–ª–µ–Ω - –∏—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
            'EMAIL_HOST_PASSWORD': 'Email Host Password',
            'SENDGRID_API_KEY': 'SendGrid API Key',
            'FACEBOOK_APP_SECRET': 'Facebook App Secret',
            'TWITTER_API_SECRET': 'Twitter API Secret',
            'GITHUB_CLIENT_SECRET': 'GitHub Client Secret',
        }
    
    def encrypt_key(self, key_name: str, api_key: str) -> str:
        """
        Encrypt a single API key.
        
        Args:
            key_name: Name of the API key
            api_key: Plain text API key
            
        Returns:
            str: Encrypted API key
        """
        if not api_key or not api_key.strip():
            raise ValueError(f"API key '{key_name}' cannot be empty")
        
        encrypted_key = encryption_service.encrypt_api_key(api_key.strip(), key_name)
        return encrypted_key
    
    def encrypt_multiple_keys(self, keys: Dict[str, str]) -> Dict[str, str]:
        """
        Encrypt multiple API keys.
        
        Args:
            keys: Dictionary of key_name -> api_key
            
        Returns:
            dict: Dictionary of key_name -> encrypted_key
        """
        encrypted_keys = {}
        for key_name, api_key in keys.items():
            try:
                encrypted_keys[key_name] = self.encrypt_key(key_name, api_key)
                print(f"‚úÖ Successfully encrypted {key_name}")
            except Exception as e:
                print(f"‚ùå Failed to encrypt {key_name}: {e}")
        
        return encrypted_keys
    
    def generate_env_file(self, encrypted_keys: Dict[str, str], output_file: str = '.env.local'):
        """
        Generate .env.local file with encrypted keys.
        
        Args:
            encrypted_keys: Dictionary of encrypted keys
            output_file: Output file path
        """
        env_lines = []
        env_lines.append("# Encrypted API Keys")
        env_lines.append("# Generated by key_encryption_tool.py")
        env_lines.append("")
        
        for key_name, encrypted_key in encrypted_keys.items():
            encrypted_var_name = f"ENCRYPTED_{key_name}"
            env_lines.append(f'{encrypted_var_name}="{encrypted_key}"')
        
        env_lines.append("")
        
        # Write to file
        with open(output_file, 'w') as f:
            f.write('\n'.join(env_lines))
        
        print(f"üìù Generated {output_file} with {len(encrypted_keys)} encrypted keys")
    
    def interactive_encrypt(self):
        """Interactive mode for encrypting keys."""
        print("üîê API Key Encryption Tool")
        print("=" * 40)
        
        keys_to_encrypt = {}
        
        print("\nAvailable API keys to encrypt:")
        for i, (key_name, description) in enumerate(self.known_keys.items(), 1):
            print(f"{i:2d}. {key_name} ({description})")
        
        print("\nEnter API keys (press Enter with empty value to skip):")
        
        for key_name, description in self.known_keys.items():
            while True:
                api_key = input(f"\n{description} ({key_name}): ").strip()
                
                if not api_key:
                    break  # Skip this key
                
                # Basic validation
                if len(api_key) < 10:
                    print("‚ö†Ô∏è  API key seems too short. Are you sure? (y/n): ", end="")
                    if input().lower() != 'y':
                        continue
                
                keys_to_encrypt[key_name] = api_key
                break
        
        if not keys_to_encrypt:
            print("‚ùå No keys to encrypt")
            return
        
        print(f"\nüîÑ Encrypting {len(keys_to_encrypt)} keys...")
        encrypted_keys = self.encrypt_multiple_keys(keys_to_encrypt)
        
        if encrypted_keys:
            print("\nüìã Encrypted keys:")
            for key_name, encrypted_key in encrypted_keys.items():
                print(f"ENCRYPTED_{key_name}=\"{encrypted_key}\"")
            
            # Ask if user wants to save to file
            save_to_file = input("\nüíæ Save to .env.local file? (y/n): ").lower() == 'y'
            if save_to_file:
                self.generate_env_file(encrypted_keys)
    
    def encrypt_from_args(self, key_name: str, api_key: str, output_file: str = None):
        """Encrypt a single key from command line arguments."""
        try:
            encrypted_key = self.encrypt_key(key_name, api_key)
            encrypted_var_name = f"ENCRYPTED_{key_name}"
            
            print(f"‚úÖ Successfully encrypted {key_name}")
            print(f"{encrypted_var_name}=\"{encrypted_key}\"")
            
            if output_file:
                with open(output_file, 'a') as f:
                    f.write(f'{encrypted_var_name}="{encrypted_key}"\n')
                print(f"üìù Appended to {output_file}")
                
        except Exception as e:
            print(f"‚ùå Failed to encrypt {key_name}: {e}")
            sys.exit(1)
    
    def list_status(self):
        """List the status of all known API keys."""
        print("üîç API Key Status")
        print("=" * 50)
        
        status = key_manager.list_available_keys()
        
        for key_name, description in self.known_keys.items():
            is_available = status.get(key_name, False)
            status_icon = "‚úÖ" if is_available else "‚ùå"
            print(f"{status_icon} {key_name:<25} ({description})")
        
        available_count = sum(status.values())
        total_count = len(self.known_keys)
        print(f"\nüìä {available_count}/{total_count} keys available")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description='Encrypt API keys for secure storage')
    parser.add_argument('--interactive', '-i', action='store_true', 
                       help='Interactive mode for encrypting multiple keys')
    parser.add_argument('--key-name', '-k', type=str, 
                       help='Name of the API key to encrypt')
    parser.add_argument('--api-key', '-a', type=str, 
                       help='API key value to encrypt')
    parser.add_argument('--output', '-o', type=str, 
                       help='Output file to append encrypted key')
    parser.add_argument('--status', '-s', action='store_true',
                       help='Show status of all API keys')
    
    args = parser.parse_args()
    
    tool = KeyEncryptionTool()
    
    if args.status:
        tool.list_status()
    elif args.interactive:
        tool.interactive_encrypt()
    elif args.key_name and args.api_key:
        tool.encrypt_from_args(args.key_name, args.api_key, args.output)
    else:
        parser.print_help()


if __name__ == '__main__':
    main()
